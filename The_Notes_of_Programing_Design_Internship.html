<style>
    h1 { color: lightyellow; }
    h2 { color: lightblue; }
    h3 { color: Lavender; }
</style>

<h1 id="-">程序设计实习笔记</h1>
<h2 id="1-">1. 类和对象</h2>
<h3 id="1-1-">1.1 使用类的成员</h3>
<p>对象名.成员名；指针-&gt;成员名；引用名.成员名</p>
<h3 id="1-2-">1.2 引用</h3>
<p>左值：可以持久储存的变量，可以进行取地址操作。</p>
<p>右值：临时对象或者字面量，不能进行取地址操作。</p>
<p>左值引用：常用于函数参数和返回值，表示对已存在对象的引用，避免拷贝，提高效率。</p>
<p>右值引用：常用于移动语义和完美转发，避免不必要的拷贝。</p>
<p>特殊地，const左值引用可以绑定到左值和右值。</p>
<p>注意，无论左值引用还是右值引用，引用本身都是左值。且引用必须再初始化时进行绑定，绑定后就不能重新绑定。</p>
<p><code>const Type&amp; ref = n</code>意为不能通过<code>ref</code>修改<code>n</code>的值，但是<code>n</code>本身可以修改，因为<code>n</code>本身并不知道<code>ref</code>的存在。</p>
<p><code>const T&amp;</code>可以绑定到<code>T&amp;</code>, <code>T</code>；<code>T&amp;</code>不可以绑定到<code>const T</code>, <code>const T&amp;</code>，本质上 是确保<code>const</code>对象不被改变。</p>
<h3 id="1-3-">1.3 类成员访问权限</h3>
<p>private: 私有成员, 只能在成员函数内访问</p>
<p>public: 公有成员, 可以在任何地方访问</p>
<p>protected: 保护成员，类内部和类外部的private，派生类的public</p>
<p>以上三种关键字出现的次数和先后次序都没有限制。</p>
<h3 id="1-4-">1.4 缺省参数</h3>
<p>注意只能是最右边的连续若干个。</p>
<h3 id="1-5-">1.5 构造函数</h3>
<p>如果不进行初始化，一般类型的值是未定义的。</p>
<p>如果定义了构造函数, 则编译器不生成默认的无参数的构造函数。</p>
<p>对象一旦生成, 就再也不能在其上执行构造函数。</p>
<p>一般而言constructor是public的，但是在单例模式中它是private的，避免用户自行创建实例。</p>
<details>
<summary>+/-单例模式</summary>

<code>cpp
class Singleton {
private:
    static Singleton* instance;
    Singleton() {} // 私有构造函数

public:
    static Singleton* getInstance() {
        if (instance == nullptr) {
            instance = new Singleton();
        }
        return instance;
    }
};

Singleton* Singleton::instance = nullptr;

int main() {
    Singleton* s1 = Singleton::getInstance();
    Singleton* s2 = Singleton::getInstance();
    std::cout &lt;&lt; (s1 == s2) &lt;&lt; std::endl; // 输出1，表示s1和s2是同一个实例
    return 0;
}</code>

</details>

<h3 id="1-6-">1.6 复制构造函数</h3>
<p>形如<code>X::X( X&amp; )</code>或<code>X::X( const X&amp; )</code>二者选一, 后者能以右值对象作为参数。不允许有形如<code>X::X( X )</code>的构造函数。</p>
<p>默认复制构造函数是<code>const X&amp;</code>类型的。如果定义的自己的复制构造函数, 则默认的复制构造函数不存在。</p>
<p>调用的三种情况：</p>
<ol>
<li><p>用一个对象初始化同类的另一个对象：<code>MyClass c2(c2)</code>或者<code>MyClass c2=c1</code></p>
</li>
<li><p>传入<code>MyClass</code>类型的形参</p>
</li>
<li><p>返回<code>MyClass</code>类型的值</p>
</li>
</ol>
<p>若加上引用则不会调用。</p>
<h3 id="1-7-">1.7 类型转换构造函数</h3>
<p>只有一个参数又不是复制构造函数的构造函数</p>
<p><code>explicit Complex(int i)</code>显式类型转换构造函数</p>
<h3 id="1-8-">1.8 析构函数</h3>
<p>一个类最多只有一个析构函数，析构函数对象消亡时自动被调用，缺省析构函数什么也不做，如果定义了析构函数, 则编译器不生成缺省析构函数。</p>
<pre><code class="lang-delete```运算导致析构函数调用。">
&lt;details&gt;
&lt;summary&gt;+/-复制构造函数与析构函数例一&lt;/summary&gt;

```cpp
<span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> {
    <span class="hljs-keyword">int</span> id;
<span class="hljs-keyword">public</span>:
    Demo(<span class="hljs-keyword">int</span> i) {
        id = i;
        printf( <span class="hljs-string">"id=%d, Construct\n"</span>, id);
    }
    ~Demo() {
        printf( <span class="hljs-string">"id=%d, Destruct\n"</span>, id);
    }
};
<span class="hljs-function">Demo <span class="hljs-title">d1</span>(<span class="hljs-params"><span class="hljs-number">1</span></span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-function"><span class="hljs-keyword">static</span> Demo <span class="hljs-title">d2</span>(<span class="hljs-params"><span class="hljs-number">2</span></span>)</span>;
    <span class="hljs-function">Demo <span class="hljs-title">d3</span>(<span class="hljs-params"><span class="hljs-number">3</span></span>)</span>;
    printf( <span class="hljs-string">"fun \n"</span>);
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> (<span class="hljs-params"></span>)</span>{
    <span class="hljs-function">Demo <span class="hljs-title">d4</span>(<span class="hljs-params"><span class="hljs-number">4</span></span>)</span>;
    printf( <span class="hljs-string">"main \n"</span>);
    { <span class="hljs-function">Demo <span class="hljs-title">d5</span>(<span class="hljs-params"><span class="hljs-number">5</span></span>)</span>; }
    fun();
    printf( <span class="hljs-string">"endmain \n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
<span class="hljs-comment">// 输出：</span>
<span class="hljs-comment">// id=1, Construct</span>
<span class="hljs-comment">// id=4, Construct</span>
<span class="hljs-comment">// main</span>
<span class="hljs-comment">// id=5, Construct</span>
<span class="hljs-comment">// id=5, Destruct</span>
<span class="hljs-comment">// id=2, Construct</span>
<span class="hljs-comment">// id=3, Construct</span>
<span class="hljs-comment">// fun</span>
<span class="hljs-comment">// id=3, Destruct</span>
<span class="hljs-comment">// endmain</span>
<span class="hljs-comment">// id=4, Destruct</span>
<span class="hljs-comment">// id=2, Destruct</span>
<span class="hljs-comment">// id=1, Destruct</span>
</code></pre>
<p></details></p>
<details>
<summary>+/-复制构造函数与析构函数例二</summary>

<code>cpp
#include &lt;iostream&gt;
using namespace std;
class CMyclass {
public:
    CMyclass() {};
    CMyclass( CMyclass &amp; c )
    {
    cout &lt;&lt; &quot;copy constructor&quot; &lt;&lt; endl;
    } ~
    CMyclass() { cout &lt;&lt; &quot;destructor&quot; &lt;&lt; endl; }
};
void fun(CMyclass obj_ ) {
    cout &lt;&lt; &quot;fun&quot; &lt;&lt; endl; 
}
CMyclass c;
CMyclass Test( ) {
    cout &lt;&lt; &quot;test&quot; &lt;&lt; endl;
    return c;
}
int main(){
    CMyclass c1;
    fun(c1);
    Test();
    return 0;
}
// 输出
// copy constructor
// fun
// destructor //参数消亡
// test
// copy constructor
// destructor // 返回值临时对象消亡
// destructor // 局部变量消亡
// destructor // 全局变量消亡</code>

</details>

<details>
<summary>+/-复制构造函数与析构函数例三</summary>

<code>cpp
#include&lt;iostream&gt;
using namespace std;

class CMyclass {
public:
    CMyclass() { cout &lt;&lt; &quot;constructor&quot; &lt;&lt; endl; }
    ~CMyclass() { cout &lt;&lt; &quot;destructor&quot; &lt;&lt; endl; }
    CMyclass(const CMyclass&amp; x)
    {
        cout &lt;&lt; &quot;copy&quot; &lt;&lt; endl;
    }
    CMyclass operator=(const CMyclass&amp; x)
    {
        cout &lt;&lt; &quot;equal&quot; &lt;&lt; endl;
        return x;
    }
};

CMyclass obj;
CMyclass fun(CMyclass sobj) { 
    return sobj;
}

int main() {
    obj = fun(obj);
    return 0;
}
// 输出
// constructor
// copy
// copy
// destructor
// equal
// copy
// destructor
// destructor
// destructor</code>

</details>

<h3 id="1-9-">1.9 静态成员</h3>
<p>在说明前面加了<code>static</code>关键字的成员（变量or函数）</p>
<pre><code class="lang-sizeof```运算符不会计算静态成员变量">
静态成员函数并不具体作用于某个对象

访问静态成员：

<span class="hljs-number">1.</span> 类名::成员名

<span class="hljs-number">2.</span> 同访问普通成员的三种方法，但本质上并不具体作用于该对象

静态成员变量本质上是全局变量：哪怕一个对象都不存在, 类的静态成员变量也存在

静态成员函数本质上是全局函数

注意：

<span class="hljs-number">1.</span> 必须在类定义的外部专门对静态成员变量进行声明，同行可进行初始化，若不初始化则全局变量自动初始化为全<span class="hljs-number">0</span>

<span class="hljs-number">2.</span> 局部类/结构体不能定义静态成员变量，因为静态成员变量本质上是全局变量，超出了该类/结构体的生存周期

<span class="hljs-number">3.</span> 静态成员不能访问非静态成员，因为不知道是谁的非静态成员；同理静态成员函数真实参数中不含this指针

### <span class="hljs-number">1.10</span> 常量对象和常量方法

常量对象只能使用:构造函数, 析构函数和常量方法

常量方法不能使用：非静态属性，非常量方法且非静态成员函数

&lt;details&gt;
&lt;summary&gt;+/-强制类型转换&lt;/summary&gt;

```cpp
void PrintfObj( const Sample &amp; o ){
    o.nonConstFun(); <span class="hljs-comment">//error</span>
    o.ConstFun(); <span class="hljs-comment">//ok</span>
    Sample &amp; r = (Sample &amp;) o; <span class="hljs-comment">//必须强制类型转换</span>
    r.nonConstFun(); <span class="hljs-comment">//ok</span>
}
</code></pre>
<p></details></p>
<p>注意：</p>
<ol>
<li><p>两个函数, 名字和参数表都一样，但是一个是const, 一个不是, 算重载</p>
</li>
<li><p><code>mutable Type</code>类型的成员变量可以在常量方法中修改</p>
</li>
</ol>
<h3 id="1-11-">1.11 成员对象和封闭类</h3>
<p>成员对象: 一个类的成员变量是另一个类的对象</p>
<p>封闭类 (enclosing)：有成员对象的类</p>
<ol>
<li>封闭类对象生成时</li>
</ol>
<p>先成员对象后封闭类，且成员对象的构造函数调用次序和成员对象在类中的说明次序一致，与它们在成员初始化列表中出现的次序无关</p>
<ol>
<li>封闭类的对象消亡时</li>
</ol>
<p>先封闭类后成员对象，次序和构造函数的调用次序相反</p>
<h3 id="1-12-const-">1.12 const成员和引用成员</h3>
<p>初始化<code>const</code>成员和引用成员, 必须在成员初始化列表中进行</p>
<h3 id="1-13-">1.13 友元</h3>
<p>一个类的友元函数（可以是其他类的成员函数）可以访问该类的私有成员</p>
<p>友元类: 如果A是B的友元类, 那么A的成员函数可以访问B的私有成员</p>
<p>注意：友元类的关系不能传递，不能继承</p>
<h2 id="2-">2. 运算符重载</h2>
<p>运算符<code>()</code> <code>[]</code> <code>-&gt;</code> <code>=</code>必须重载为成员函数（等括箭-&gt;等扩建）。</p>
<p>运算符<code>+</code> <code>*</code>等常重载为友元函数。</p>
<p>以下运算符不能被重载:<code>.</code> <code>::</code> <code>?:</code> <code>sizeof</code>。<code>&amp;</code>只能重载为按位与。</p>
<p>运算符重载不改变运算符的优先级。</p>
<p>重载运算符是为了让它能作用于对象, 因此重载运算符不允许操作数都不是对象。</p>
<p>类型选择分析：</p>
<ol>
<li>返回值类型：一般不使用<code>const</code>修饰，除非为了安全性考虑不想让返回值成为左值；是否引用取决于返回的是当前对象本身还是临时对象（当然可以结合运算符原本的性质考虑）。</li>
<li>传入参数类型：一般均为<code>const ClassName &amp;</code></li>
</ol>
<h3 id="2-1-">2.1 +/-运算符重载</h3>
<p>重载为成员函数则首个操作数必须为对象，故往往重载为<strong>友元函数</strong>以满足交换律。</p>
<p>返回类型为临时对象，与原运算符的性质契合。如果返回类型设定为引用，则会产生<strong>悬垂引用</strong>。</p>
<details>
<summary>+/-重载的实现</summary>

<code>cpp
class Complex {
public:
    double real, imag;
    Complex( double r = 0.0, double i= 0.0 ):real(r), imag(i) { }
    Complex operator-(const Complex &amp; c);
};
Complex operator+( const Complex &amp; a, const Complex &amp; b){
    return Complex( a.real+b.real, a.imag+b.imag);
    //返回一个临时对象
}
Complex Complex::operator-(const Complex &amp; c){
    return Complex(real - c.real, imag - c.imag);
    //返回一个临时对象
}</code>

</details>

<h3 id="2-2-">2.2 =赋值运算符重载</h3>
<p>只能重载为<strong>成员函数</strong>（因为赋值运算符的左侧必须是可赋值对象lvalue，不能是临时对象或者右值rvalue，这样操作可以确保这一点）。</p>
<p>返回值类型为<code>ClassName &amp;</code>或者<code>const ClassName &amp;</code>，用引用是为了支持链式操作，至于<code>const</code>修饰与否的差别主要在于是否支持<code>(a = b) = c</code>这样的操作，有时为了灵活性选择不修饰，有时为了安全性选择修饰。(本质上是加了<code>const</code>之后就不能是lvalue了)</p>
<details>
<summary>右值为基本类型的实现</summary>

<code>cpp
class String {
private:
    char * str;
public:
    String () : str(new char[1]) { str[0] = 0; }
    const char * c_str() { return str; }
    String &amp; operator = (const char * s);
    ~String() { delete [] str; }
};

String &amp; String::operator = (const char * s){
    delete [] str;
    str = new char[strlen(s)+1];
    strcpy(str, s);
    return *this;
}

int main(){
    String s;
    s = &quot;Good Luck,&quot; ;
    cout &lt;&lt; s.c_str() &lt;&lt; endl;
    s = &quot;Shenzhou 13!&quot;;
    cout &lt;&lt; s.c_str() &lt;&lt; endl;
    return 0;
}</code>
</details>

<p><br></p>
<details>
<summary>右值为类对象的实现</summary>

<code>cpp
String &amp; operator = (const String &amp; s) {
    if(this == &amp;s) return * this;//避免自赋值时的问题
    delete [] str;
    str = new char[strlen(s.str)+1];
    strcpy(str, s.str);
    return * this;
}</code>
</details>

<p><br></p>
<details>
<summary>复制构造函数的实现（避免shallow copy）</summary>

<code>cpp
String(const String &amp; s) {
    str = new char[strlen(s.str)+1];
    strcpy(str, s.str);
}</code>
</details>

<h3 id="2-3-">2.3 流运算符重载</h3>
<pre><code class="lang-istream```和```ostream```类本身可以完成对基本类型的输入输出，其内部会管理一个输入输出的缓冲区。此处重载是为了直接输入输出类的对象。">
返回值类型为```istream &amp;```和```ostream &amp;```，不用```const```修饰是为了支持链式操作（否则后续无法修改缓冲区），使用引用是为了支持链式操作（连续地对同一个流对象进行操作），且每次返回会创建一个copy造成不必要的性能开销。

通常把流运算符重载为友元函数（因其首个操作数显然不为对象），但输出流也可以强行重载为成员函数，输入流不可（其第一个参数必须为```istream &amp;```）


&lt;details&gt;
&lt;summary&gt;右值为基本类型的实现&lt;/summary&gt;

```cpp
ostream &amp; operator&lt;&lt; ( ostream &amp; o,
    const CStudent &amp; s){
    o &lt;&lt; s.nAge;
    return o;
}
</code></pre>
<p></details></p>
<h3 id="2-4-">2.4 []运算符重载</h3>
<p>大部分时候默认复制构造函数都会导致shallow copy，要记得写自己的复制构造函数。</p>
<details>
<summary>[]重载的实现</summary>

<code>cpp
class Array{
public:
    Array(int n = 10) : size(n) { ptr = new int[n]; }
    ~Array() { delete [] ptr; }
    int &amp; operator[](int subscript){
        return ptr[subscript];
    }
private:
    int size;
    int *ptr;
};</code>
</details>

<p><br></p>
<details>
<summary>相应的赋值重载以及复制构造函数</summary>

<code>cpp
const Array &amp; operator=( const Array &amp; a)
{
    if( ptr == a.ptr ) return * this;
    delete [] ptr;
    ptr = new int[ a.size ];
    memcpy( ptr, a.ptr, sizeof(int ) * a.size);
    size = a.size;
    return * this;
} //返回const array &amp; 类型是为了高效实现
//a = b = c; 形式

Array(Array &amp; a) {
    ptr = new int[ a.size ];
    memcpy( ptr, a.ptr, sizeof(int) * a.size);
    size = a.size;
}</code>
</details>

<h3 id="2-5-">2.5 类型转换运算符重载</h3>
<p>必须为成员函数, 不指定返回类型（因为运算符已经指明了类型）, 形参为空；一般不改变被转换对象（常定义为const）；触发类型转换时自动调用。</p>
<details>
<summary>类型转换运算符重载的实现</summary>

<code>cpp
class Sample {
private :
    int n;
public:
    Sample(int i){
        n=i;
        cout&lt;&lt;&quot;constructor called&quot;&lt;&lt;endl;
    }
    Sample operator+(int k){
    Sample tmp(n + k);
        return tmp;
    }
    operator int ( ) { //重载类型强制转换运算符
        cout&lt;&lt;&quot;int convertor called&quot;&lt;&lt;endl;
        return n;
    }
};</code>
</details>

<h3 id="2-6-">2.6 ++/--运算符重载</h3>
<p>无参为前置，有int参为后置。</p>
<p>前置的返回值类型选取<code>ClassName &amp;</code>，因为返回的是当前对象的引用，从而支持链式操作并且提高效率；后置的返回值类型选取<code>ClassName</code>，因为返回的是一个临时对象。</p>
<p>成员函数中无需多言；友元函数中，传入的对象类型为<code>ClassName &amp;</code>从而直接对当前对象进行操作。</p>
<p>至于为什么都不用<code>const</code>：返回值类型需要确保可以继续操作，故而不用<code>const</code>；参数类型需要对传入的引用进行修改，显然不能<code>const</code>。</p>
<details>
<summary>++/--运算符重载的实现</summary>

<code>cpp
class CDemo {
private :
    int n;
public:
    CDemo(int i=0):n(i) { }
    CDemo &amp; operator++( ); //用于前置形式
    CDemo operator++( int ); //用于后置形式
    operator int ( ) { return n; }
    friend CDemo &amp; operator--( CDemo &amp; );
    friend CDemo operator--( CDemo &amp;, int);
};

// ++s即为: s.operator++();
CDemo &amp; CDemo::operator++()
{ //前置 ++
    n ++;
    return * this;
}

// s++即为: s.operator++(0);
CDemo CDemo::operator++( int k )
{ //后置 ++
    CDemo tmp(*this); //记录修改前的对象
    n ++;
    return tmp; //返回修改前的对象
}

//--s即为: operator--(s);
CDemo &amp; operator--(CDemo &amp; d)
{ //前置--
    d.n--;
    return d;
}

//s--即为: operator--(s, 0);
CDemo operator--(CDemo &amp; d, int)
{ //后置--
    CDemo tmp(d);
    d.n --;
    return tmp;
}</code>
</details>


<h2 id="3-">3. 继承和派生</h2>
<h3 id="3-1-">3.1 概念</h3>
<p><code>class DerivedClass : public/protected/private BaseClass</code></p>
<pre><code class="lang-public```时只有```private```不能访问">
注意：

<span class="hljs-number">1.</span> 继承是“是”关系

<span class="hljs-number">2.</span> 复合（不同于enclosing）是“有”关系，且为了避免循环定义，需要提前声明类&amp;&amp;使用对象指针

&lt;details&gt;
&lt;summary&gt;+/-复合类&lt;/summary&gt;

`<span class="javascript"></span>``<span class="javascript">cpp
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CDog</span></span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CMaster</span>
</span>{
    CDog * dogs[<span class="hljs-number">10</span>];
};
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CDog</span>
</span>{
    CMaster * m;
};</span>
</code></pre>
<p></details></p>
<h3 id="3-2-">3.2 内存</h3>
<p>派生类对象的大小, 等于基类对象的大小 + 派生类对象自己的成员变量的大小</p>
<p>在派生类对象中, 包含着基类对象, 而且基类对象的存储位置位于派生类对象新增的成员变量之前</p>
<h3 id="3-3-">3.3 覆盖</h3>
<p>覆盖：派生类中定义一个和基类成员同名的成员</p>
<p>访问时:</p>
<ol>
<li><p>缺省的情况访问派生类中定义的成员</p>
</li>
<li><p><code>BaseClass::</code>访问由基类定义的同名成员</p>
</li>
</ol>
<h3 id="3-4-protected-">3.4 protected访问权限</h3>
<p>可以访问当前对象的基类保护成员：若覆盖则指明作用域</p>
<p>也可以访问其它<strong>同类对象</strong>的基类保护成员</p>
<p>派生类的友元函数也可以访问基类的保护成员（甚至不需传入类参数）</p>
<p>注意：不能访问基类对象的保护成员</p>
<h3 id="3-5-">3.5 三种继承方式</h3>
<table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protected</th>
<th>private</th>
</tr>
</thead>
<tbody>
<tr>
<td>公有继承</td>
<td>public</td>
<td>protected</td>
<td>无</td>
</tr>
<tr>
<td>私有继承</td>
<td>private</td>
<td>private</td>
<td>无</td>
</tr>
<tr>
<td>保护继承</td>
<td>protected</td>
<td>protected</td>
<td>无</td>
</tr>
</tbody>
</table>
<h3 id="3-6-">3.6 构造函数和析构函数</h3>
<ol>
<li>无成员对象时：</li>
</ol>
<p>构造函数：先基类后派生类（内存区域从前到后？）</p>
<p>析构函数：先派生类后基类（内存区域从后到前？）</p>
<ol>
<li>有成员对象时：</li>
</ol>
<p>构造函数：先基类再成员对象类最后派生类</p>
<p>析构函数：先派生类再成员对象类最后基类</p>
<h3 id="3-7-public-">3.7 public赋值兼容</h3>
<pre><code class="lang-public```派生类的对象可以">
<span class="hljs-number">1.</span> 赋值给基类对象

<span class="hljs-number">2.</span> 初始化基类引用

<span class="hljs-number">3.</span> 地址可以赋值给基类指针

注意：如果派生方式是```private```或```protected```, 则上述三条不可行。本质上是因为属性的类别不同了。

&lt;details&gt;
&lt;summary&gt;强制类型转换&lt;/summary&gt;

```cpp
Base * ptrBase = &amp;objDerived;
Derived *ptrDerived = (Derived * ) ptrBase;
</code></pre>
<p></details></p>
<h3 id="3-8-">3.8 直接基类与间接基类</h3>
<p>在声明派生类时, 派生类的首部只需要列出它的直接基类，不要列出它的间接基类。</p>
<details>
<summary>反例</summary>

<code>cpp
class A {};

class B : public A {};

class C : public A, public B {};
// C会包含两份A
// 可以使用虚继承</code>
</details>

<details>
<summary>虚继承</summary>

<code>cpp
class A {};

class B : virtual public A {};

class C : virtual public A, public B {};</code>
</details>

<table>
<thead>
<tr>
<th>特性</th>
<th>普通继承</th>
<th>虚继承</th>
</tr>
</thead>
<tbody>
<tr>
<td>基类子对象数量</td>
<td>可能多份（菱形继承问题）</td>
<td>仅一份</td>
</tr>
<tr>
<td>初始化责任</td>
<td>由直接派生类初始化</td>
<td>由最底层派生类初始化</td>
</tr>
<tr>
<td>适用场景</td>
<td>单继承或简单多重继承</td>
<td>菱形继承</td>
</tr>
<tr>
<td>性能开销</td>
<td>无额外开销</td>
<td>需维护虚基类表（略慢）</td>
</tr>
</tbody>
</table>
<h3 id="3-9-">3.9 多继承</h3>
<p>构造函数：先基类（按继承顺序）再成员对象类最后派生类</p>
<p>析构函数：与构造反过来即可</p>
<h2 id="4-">4. 多态</h2>
<h3 id="4-1-">4.1 概念</h3>
<p>虚函数：<code>virtual int fun()</code>或者<code>int virtual fun()</code></p>
<p>注意：</p>
<ol>
<li><p>只需要在定义时添加说明符即可，写函数体时不能添加</p>
</li>
<li><p>静态成员函数不能是虚函数，因为静态成员函数没有<code>this</code>指针，且静态函数是类级别的</p>
</li>
<li><p>多层继承时，从有<code>virtual</code>开始的派生类中同名函数均为虚函数</p>
</li>
</ol>
<h3 id="4-2-">4.2 多态使用方法</h3>
<ol>
<li><p>用基类指针：</p>
</li>
<li><p>若该指针指向一个基类的对象, 则被调用是基类的虚函数</p>
</li>
<li><p>若该指针指向一个派生类的对象, 则被调用的是派生类的虚函数</p>
</li>
<li><p>用基类引用：</p>
</li>
<li><p>若该引用的是一个基类的对象, 那么被调用是基类的虚函数</p>
</li>
<li>若引用的是一个派生类的对象, 那么被调用的是派生类的虚函数</li>
</ol>
<h3 id="4-3-">4.3 动态联编</h3>
<p>动态联编：一条函数调用语句在编译时无法确定调用哪个函数，运行到该语句时才确定调用哪个函数</p>
<h3 id="4-4-">4.4 多态的实现原理</h3>
<p>虚函数的调用版本是由对象的<strong>动态类型</strong>决定的，具体实现是通过<strong>虚函数表</strong>（Virtual Table，简称 vtable）和<strong>虚函数指针</strong>（Virtual Pointer，简称 vptr）来完成的。</p>
<ol>
<li><p>虚函数表（vtable）:</p>
<p> 每个包含虚函数的类在编译时都隐式生成一个 vtable 作为静态数据成员，其中存储了该类中所有虚函数的实际地址。基类和派生类的vtable是不同的。</p>
</li>
<li><p>虚函数指针（vptr）:</p>
<p> 每个对象在创建时，都会被分配一个隐藏的 vptr，其由构造函数进行设置（故构造函数不能是虚函数），指向其所属类的 vtable。当调用虚函数时，程序通过对象的 vptr 找到其 vtable，然后通过 vtable 调用相应的虚函数。</p>
</li>
</ol>
<details>
<summary>+/-多态的实现原理</summary>

<code>cpp
class Base {
public:
    virtual void func1() { /* Base的实现 */ }
    virtual void func2() { /* Base的实现 */ }
    int data;
};

class Derived : public Base {
public:
    void func1() override { /* Derived的实现 */ }
    virtual void func3() { /* 新增虚函数 */ }
};
// Base对象:
// [vptr] -&gt; Base的vtable [&amp;Base::func1, &amp;Base::func2]
// [data]

// Derived对象:
// [vptr] -&gt; Derived的vtable [&amp;Derived::func1, &amp;Base::func2, &amp;Derived::func3]
// [data]</code>

</details>

<h3 id="4-5-">4.5 虚函数的访问权限</h3>
<p>访问权限检查是根据指针类型来的</p>
<details>
<summary>+/-访问权限例一</summary>

<code>cpp
class Base {
private:
    virtual void fun2() { cout &lt;&lt; &quot;Base::fun2()&quot; &lt;&lt; endl; }
};
class Derived:public Base {
public:
    virtual void fun2() { cout &lt;&lt; &quot;Derived:fun2()&quot; &lt;&lt; endl; }
};
Derived d;
Base * pBase = &amp; d;
pBase -&gt; fun2(); // 编译出错</code>

</details>

<details>
<summary>+/-访问权限例二</summary>

<code>cpp
class Base {
public:
    virtual void fun2() { cout &lt;&lt; &quot;Base::fun2()&quot; &lt;&lt; endl; }
};
class Derived:public Base {
private:
    virtual void fun2() { cout &lt;&lt; &quot;Derived:fun2()&quot; &lt;&lt; endl; }
};
Derived d;
Base * pBase = &amp; d;
pBase -&gt; fun2(); // 输出Derived::fun2()</code>

</details>

<h3 id="4-6-">4.6 虚析构函数</h3>
<ol>
<li><p>构造函数：</p>
<p> 总是由实际创建的对象类型决定，而与声明类型无关；且构造函数不能 virtual</p>
</li>
<li><p>析构函数：</p>
<ul>
<li><p>对于栈对象：总是调用完整析构链</p>
</li>
<li><p>对于堆对象：</p>
<p>virtual析构函数会实现多态析构</p>
<p>非virtual析构函数会导致派生部分不被析构</p>
</li>
</ul>
</li>
</ol>
<p>注意：</p>
<ol>
<li><p><code>Base* p = new Derived()</code>中，<code>p</code>存放在栈中，但是由<code>new</code>/<code>malloc</code>分配的指针指向堆内存，故此时析构不得不虚</p>
</li>
<li><p>无论是构造函数还是析构函数，调用虚函数时都会在编译时确定，而不会动态联编。因为执行它们的百分百是当前类的对象（毕竟名字都不同）</p>
</li>
</ol>
<h3 id="4-7-">4.7 纯虚函数和抽象类</h3>
<p>纯虚函数：没有函数体的虚函数，如<code>virtual void Print( ) = 0 ;</code></p>
<p>抽象类：包含纯虚函数的类叫抽象类</p>
<p>注意：</p>
<ol>
<li><p>抽象类只能作为基类来派生新类使用, 不能创建抽象类的对象</p>
</li>
<li><p>抽象类的指针和引用可以指向由抽象类派生出来的类的对象</p>
</li>
</ol>
<p>在抽象类的成员函数内可以调用纯虚函数，但是在构造函数或析构函数内部不能调用纯虚函数（因为构造与析构都会直接调用纯虚函数导致无定义）</p>
<p>如果一个类从抽象类派生而来, 那么当且仅当它实现了基类中的所有纯虚函数, 它才能成为非抽象类</p>
<h2 id="5-">5. 输入输出与文件操作</h2>
<h3 id="5-1-">5.1 有关类</h3>
<p>&lt;!DOCTYPE html&gt;</p>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Class Inheritance Tree</title>
    <style>
        .tree {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: Arial, sans-serif;
        }
        .node {
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 5px;
            background-color:rgba(75, 81, 118, 0.85);
        }
        .node &gt; .node {
            margin-top: 20px;
        }
        .line {
            border-left: 1px solid #ccc;
            border-top: 1px solid #ccc;
            width: 50px;
            height: 50px;
            position: relative;
            top: -25px;
            left: 25px;
        }
        .line::before {
            content: &#39;&#39;;
            position: absolute;
            top: -25px;
            left: 0;
            border-left: 1px solid #ccc;
            border-top: 1px solid #ccc;
            width: 25px;
            height: 25px;
        }
        .line::after {
            content: &#39;&#39;;
            position: absolute;
            top: 0;
            left: 25px;
            border-left: 1px solid #ccc;
            border-top: 1px solid #ccc;
            width: 25px;
            height: 25px;
        }
    </style>
</head>
<body>
    <div class="tree">
        <div class="node">ios_base
            <div class="node">ios
                <div class="node">istream
                    <div class="node">ifstream</div>
                    <div class="node">fstream</div>
                </div>
                <div class="node">ostream
                    <div class="node">ofstream</div>
                    <div class="node">fstream</div>
                </div>
            </div>
        </div>
    </div>
</body>
</html>

<ul>
<li><p>istream：用于输入的流类, cin 就是该类的对象</p>
</li>
<li><p>ostream：用于输出的流类, cout 就是该类的对象</p>
</li>
<li><p>iostream：既能用于输入, 又能用于输出的类</p>
</li>
<li><p>ifstream：用于从文件读取数据的类</p>
</li>
<li><p>ofstream：用于向文件写入数据的类</p>
</li>
<li><p>fstream：既能从文件读取数据, 又能向文件写入数据的类</p>
</li>
</ul>
<h3 id="5-2-">5.2 标准流对象与重定向</h3>
<p>重定向: 将输入的源或输出的目的地改变</p>
<ol>
<li><p>输入：</p>
<p> 输入流对象：<code>cin</code></p>
<p> 重定向：<code>freopen(&quot;filename.txt&quot;, &quot;r&quot;, stdin);</code></p>
</li>
<li><p>输入：</p>
<p> 输入流对象：<code>cout</code>, <code>cerr</code>, <code>clog</code></p>
<ul>
<li><p>cerr (无缓冲)</p>
<p>  数据会立即输出到设备, 如终端或日志文件, 不经过缓冲区；适用于紧急错误、调试信息 (确保即使程序崩溃也能输出)</p>
</li>
<li><p>clog (带缓冲)</p>
<p>  数据先存入缓冲区, 缓冲区满或手动刷新时才输出; 适用于非紧急日志记录, 性能更高 (减少频繁I/O操作), 常规日志记录 (如程序运行状态、非关键警告, 允许延迟输出)</p>
<p>  可用<code>flush</code>手动冲刷</p>
</li>
</ul>
</li>
</ol>
<pre><code>重定向：```freopen(<span class="hljs-string">"filename.txt"</span>, <span class="hljs-string">"w"</span>, stdout);```

注意：这只是重定向了```std::out```，并没有改变另外两个输入流对象。
</code></pre><h3 id="5-3-">5.3 判断输入流结束</h3>
<p>重载<code>operator bool()</code>强制类型转换</p>
<h3 id="5-4-istream-">5.4 istream类</h3>
<p>标志状态：ios_base类的静态成员常量</p>
<ul>
<li><code>std::ios_base::goodbit</code>：表示输入流状态良好，没有发生任何错误</li>
<li><code>std::ios_base::eofbit</code>：表示输入流已经到达文件末尾（End Of File，EOF）</li>
<li><code>std::ios_base::failbit</code>：表示输入流发生了格式错误或读取失败</li>
<li><code>std::ios_base::badbit</code>：表示输入流发生了严重错误，例如无法读取文件</li>
</ul>
<p>可以通过<code>object.eof()</code>, <code>object.fail()</code>, <code>object.bad()</code>分别进行访问</p>
<p><code>istream &amp; getline(char * buf, int bufSize);</code>
从输入流中读取(bufSize-1)个字符到缓冲区, 或读到<code>\n</code>为止(哪个先到算哪个)</p>
<p><code>istream &amp; getline(char * buf, int bufSize, char delim);</code>
从输入流中读取(bufSize-1)个字符到缓冲区, 或读到<code>delim</code>为止</p>
<p>注意：</p>
<ol>
<li><p>两个函数都会自动在缓冲区中读入数据的结尾添加 <code>\0</code></p>
</li>
<li><p><code>\n</code>或<code>delim</code>都不会被读入缓冲区, 但会被从输入流中取走</p>
</li>
<li><p>如果输入流<code>\n</code>或<code>delim</code>之前的字符个数超过了<code>bufSize</code>个, 就导致读入出错（标志状态设为<code>std::ios_base::failbit</code>）, 其结果就是: 本次读入已经完成, 但之后的读入就都会失败(可以用<code>cin.clear()</code>清除状态标志)。</p>
</li>
</ol>
<p>更多成员函数：</p>
<p><code>bool eof();</code>：判断输入流是否结束</p>
<p><code>int peek();</code>：返回下一个字符, 但不从流中去掉</p>
<p><code>istream &amp; putback( char c );</code>：将字符<code>c</code>放回输入流</p>
<p><code>istream &amp; ignore(int nCount = 1, int delim = EOF );</code>：从流中删掉最多<code>nCount</code>个字符, 遇到<code>delim</code>时结束</p>
<h3 id="5-5-">5.5 流操纵算子</h3>
<pre><code class="lang-#include&lt;iomanip&gt;```头文件">
注：```endl```除了换行还可以冲刷缓冲区，```\n```不行

<span class="hljs-number">1.</span> 整数流的基数: 

    ```dec```, ```oct```, ```hex```, ```setbase```(只能<span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">16</span>)

<span class="hljs-number">2.</span> 浮点数的精度:

    成员函数：```cout.pricision(num)
</code></pre>
<pre><code>流操纵算子：```cout&lt;&lt;pricision(num)```

功能：

- 指定输出浮点数的有效位数（非定点方式输出时）

- 指定输出浮点数的小数点后的有效位数（定点方式输出时```std::fixed```，确保不使用科学计数法```scientific```）

也可以```setiosflags(ios::fixed)```定点
```seiosflags(ios::scientific)```科学计数法
```resetiosflags(...)```取消之前的设置

注意：

<span class="hljs-number">1.</span> 输出最多```num```位有效数字（可以不到）

<span class="hljs-number">2.</span> 会四舍五入
</code></pre><ol>
<li><p>设置域宽:</p>
<p> 域宽：输出时所占的最小字符数，默认为1</p>
<p> 成员函数：<code>cin.width(num)</code>无参输出当前域宽</p>
<p> 流操纵算子：<code>setw(num)</code></p>
<p> 注意：</p>
<ol>
<li><p>输入操作提取字符串的最大宽度比定义的域宽小1, 因为在输入的字符串后面必须加上一个空字符</p>
</li>
<li><p>每次读入和输出之前都要设置宽度</p>
</li>
</ol>
</li>
<li><p>用户自定义的流操纵算子</p>
<p> 有对<code>&lt;&lt;</code>的重载</p>
<pre><code class="lang-cpp"> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; (*p)(ostream&amp;))
 {
     <span class="hljs-keyword">return</span> p(*<span class="hljs-keyword">this</span>);
 }
</code></pre>
<p> 故直接</p>
<pre><code class="lang-cpp"> ostream&amp; tab(ostream&amp; <span class="hljs-keyword">out</span>)
 {
     <span class="hljs-keyword">return</span> <span class="hljs-keyword">out</span>&lt;&lt;<span class="hljs-string">"\t"</span>;
 }
</code></pre>
<p> 即可自定义</p>
</li>
</ol>
<h3 id="5-6-">5.6 建立顺序文件</h3>
<p>顺序文件：将所有记录顺序地写入一个文件</p>
<ol>
<li><p>建立：</p>
<pre><code class="lang-cpp"> <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span> <span class="hljs-comment">// 包含头文件</span></span>

 <span class="hljs-function">ofstream <span class="hljs-title">fileObject</span><span class="hljs-params">(<span class="hljs-string">"filename.txt"</span>, ios::out|ios::binary)</span></span>; <span class="hljs-comment">//打开文件</span>

 <span class="hljs-comment">//另一种方法</span>
 ofstream fout;
 fout.open(<span class="hljs-string">"filename.txt"</span>, ios::out|ios::binary);

 <span class="hljs-comment">// 判断打开是否成功：</span>
 <span class="hljs-keyword">if</span> (!fout) { <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"File open error!"</span> &lt;&lt;<span class="hljs-built_in">endl</span>; }
</code></pre>
<p> 其中</p>
<ul>
<li><code>ios::out</code> 输出到文件, 删除原有内容</li>
<li><code>ios::app</code> 输出到文件, 保留原有内容, 总是在尾部添加(append)</li>
<li><code>ios::ate</code> 输出到文件, 保留原有内容, 在文件任意位置
添加(at end)</li>
<li><code>ios::binary</code> 以二进制文件格式打开文件</li>
</ul>
</li>
<li><p>读写</p>
<p> 对于输入文件, 有一个读指针</p>
<p> 对于输出文件, 有一个写指针</p>
<p> 对于输入输出文件, 有一个读写指针</p>
<p> 读指针（get pointer）：</p>
<pre><code class="lang-fin.tellg```：取得读指针的位置">
 ```fin.seekg(location)```：将读指针移动到第```location```个字节处（可以为负）

 ```fin.seekg(location, ios::beg);```：从头数```location
</code></pre>
<p> <code>fin.seekg(location, ios::cur);</code>：从当前数<code>location</code></p>
<p> <code>fin.seekg(location, ios::end);</code>：从尾数<code>location</code></p>
<p> 读指针（put pointer）：</p>
<pre><code class="lang-fout.tellp```：取得读指针的位置">
 ```fout.seekp(location)```：将读指针移动到第```location```个字节处（可以为负）

 ```fout.seekp(location, ios::beg);```：从头数```location
</code></pre>
<p> <code>fout.seekp(location, ios::cur);</code>：从当前数<code>location</code></p>
<p> <code>fout.seekp(location, ios::end);</code>：从尾数<code>location</code></p>
<p> 读操作：</p>
<p> <code>fin.read((char *)(&amp;x), sizeof(Type));</code></p>
<pre><code class="lang-fin.gcount();```看上一次读入几个字节">
 ```fin.get(char c)```每次读取一个字符

 写操作：

 ```fout.write((const char *)(&amp;x), sizeof(Type));
</code></pre>
<p> <code>fout.put(char c)</code>每次写入一个字符</p>
<p> 注意：读无<code>const</code>因为会修改指针指向区域，写有<code>const</code>因为不能修改原有数据</p>
</li>
<li><p>关闭</p>
<p> 需要显示关闭文件</p>
<p> <code>fin.close()</code>和<code>fout.close()</code></p>
</li>
</ol>
<h3 id="5-7-">5.7 二进制文件和文本文件</h3>
<ol>
<li><p>Linux / Unix下的换行符号：</p>
<p> <code>\n</code>(ASCII码: <code>0x0a</code>)，故Unix/Linux下打开文件, 用不用<code>ios::binary</code>没区别</p>
</li>
<li><p>Windows下的换行符号：</p>
<p> 文本文件：<code>\r\n</code>(ASCII码：<code>0x0d 0x0a</code>)</p>
<p> 二进制文件：<code>\n</code></p>
<ul>
<li><p>若不使用<code>ios::binary</code>，则读取时, 系统会将<code>0x0d 0x0a</code>只读入<code>0x0a</code>；写入时, 对于<code>0x0a</code>系统会自动补上<code>0x0d</code></p>
</li>
<li><p>若使用<code>ios::binary</code>，则读取和写入都一板一眼</p>
</li>
</ul>
</li>
<li><p>Mac OS下的换行符号：<code>\r</code>(ASCII码：<code>0x0d</code>)</p>
</li>
</ol>
<p>故Linux, Mac OS 文本文件在Windows 记事本中打开时不换行</p>
<h2 id="6-">6. 模板</h2>
<h3 id="6-1-">6.1 函数模板</h3>
<p>由编译系统根据调用时实参的类型, 自动生成相应的模板函数</p>
<p>也可以在<code>&lt;&gt;</code>中指定类型参数所对应的具体类型来实例化</p>
<p>函数模板的参数类型：可以用类型参数说明；也可以用基本数据类型, 其他的类说明</p>
<p>同名函数模板也可以重载，参数（类型参数，形参）数量不同即可</p>
<p>注意：分开定义时，后面也要写<code>template&lt;&gt;</code></p>
<p><strong>调用顺序</strong>：
先找参数完全匹配的函数，再找参数完全匹配的模板，再找参数自动转换后能匹配的函数（要求没有二义性）。总之，越精确越好。</p>
<h3 id="6-2-">6.2 类模板</h3>
<p>主模板声明时</p>
<pre><code class="lang-cpp"><span class="hljs-keyword">template</span> &lt;类型参数表&gt;
<span class="hljs-keyword">class</span> 类模板名;
</code></pre>
<p>在类模板外定义时（注意<code>T</code>只是一个记号）</p>
<pre><code class="lang-cpp"><span class="xml">template <span class="hljs-tag">&lt;<span class="hljs-name">类型参数表</span>&gt;</span>
返回值类型 类模板名<span class="hljs-tag">&lt;<span class="hljs-name">类型参数名列表</span>&gt;</span>::成员函数名(参数表)</span><span class="hljs-template-variable">{
    ...
}</span><span class="xml"></span>
</code></pre>
<p>同⼀个类模板的两个模板类是不兼容的</p>
<p>类模板中的成员函数可以是⼀个函数模板，该成员函数只有在被调⽤时才会被实例化</p>
<p>可以包括非类型参数（函数模板也可以），用以说明类模板中的属性</p>
<h3 id="6-3-">6.3 继承与派生</h3>
<p>类模板可以派生类模板，模板类可以派生类模板，普通类可以派生类模板，模板类可以派生普通类</p>
<p>注：本质上模板类和普通类没有区别，都失去了随机性（塌缩了）。可以认为只有四种关系，四种里面只有随机派生出确定不行（类模板派生模板类/普通类不行，因为构造时必须传入类型参数，传入不了）</p>
<h3 id="6-4-">6.4 类模板与友元函数</h3>
<p>简单来说就是都可以</p>
<pre><code class="lang-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
<span class="hljs-keyword">class</span> FriendTemplate;

<span class="hljs-comment">// 定义一个普通类</span>
<span class="hljs-keyword">class</span> MyClass {
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> secret;

<span class="hljs-keyword">public</span>:
    MyClass(<span class="hljs-keyword">int</span> s) : secret(s) {}

    <span class="hljs-comment">// 将类模板 FriendTemplate 声明为友元</span>
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> FriendTemplate;
};

<span class="hljs-comment">// 定义一个类模板</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> FriendTemplate {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MyClass&amp; x)</span> </span>{
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Displaying: "</span> &lt;&lt; x.secret &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">MyClass <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span></span>;

    <span class="hljs-comment">// 创建类模板的实例</span>
    FriendTemplate&lt;<span class="hljs-keyword">int</span>&gt; ft;
    ft.display(obj); <span class="hljs-comment">// 友元类可以访问私有成员</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h3 id="6-5-">6.5 特化</h3>
<p>使用<code>template&lt;&gt;</code>可以进行显示特化，</p>
<details>
<summary>+/-显示特化类模板</summary>

<code>cpp
#include &lt;iostream&gt;
using namespace std;

// 定义一个类模板
template &lt;typename T&gt;
class MyTemplate {
public:
    void display() {
        cout &lt;&lt; &quot;Generic template for type &quot; &lt;&lt; typeid(T).name() &lt;&lt; endl;
    }
};

// 显式特化类模板
template&lt;&gt;
class MyTemplate&lt;int&gt; {
public:
    void display() {
        cout &lt;&lt; &quot;Explicit specialization for int&quot; &lt;&lt; endl;
    }
};

int main() {
    MyTemplate&lt;double&gt; obj1;
    obj1.display(); // 使用通用模板

    MyTemplate&lt;int&gt; obj2;
    obj2.display(); // 使用显式特化

    return 0;
}</code>

</details>

<details>
<summary>+/-显式特化函数模板</summary>

<code>cpp
#include &lt;iostream&gt;
using namespace std;

// 定义一个函数模板
template &lt;typename T&gt;
void print(T value) {
    cout &lt;&lt; &quot;Generic template: &quot; &lt;&lt; value &lt;&lt; endl;
}

// 显式特化函数模板
template&lt;&gt;
void print&lt;int&gt;(int value) {
    cout &lt;&lt; &quot;Explicit specialization for int: &quot; &lt;&lt; value &lt;&lt; endl;
}

int main() {
    print(3.14); // 使用通用模板
    print(42);   // 使用显式特化
    return 0;
}</code>

</details>


<details>
<summary>+/-偏特化</summary>

<code>cpp
#include &lt;iostream&gt;
using namespace std;

// 定义一个类模板
template &lt;typename T1, typename T2&gt;
class MyTemplate {
public:
    void display() {
        cout &lt;&lt; &quot;Generic template for types &quot; &lt;&lt; typeid(T1).name() &lt;&lt; &quot; and &quot; &lt;&lt; typeid(T2).name() &lt;&lt; endl;
    }
};

// 偏特化，为第一个参数是 int 的情况提供特化
template &lt;typename T2&gt;
class MyTemplate&lt;int, T2&gt; {
public:
    void display() {
        cout &lt;&lt; &quot;Partial specialization for int and &quot; &lt;&lt; typeid(T2).name() &lt;&lt; endl;
    }
};

int main() {
    MyTemplate&lt;double, float&gt; obj1;
    obj1.display(); // 使用通用模板

    MyTemplate&lt;int, float&gt; obj2;
    obj2.display(); // 使用偏特化

    return 0;
}</code>

</details>


<h2 id="7-">7.</h2>
